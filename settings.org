#+TITLE:   Sean's Emacs Configuration
#+AUTHOR:  Sean Duckett
#+EMAIL:   sean@hungryllama.net
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

* Introduction

This is an experiment to see how keeping a literate configuration for Emacs
feels; how does it affect my thinking of the system as a whole? There might be
things that don't work, broken code, and descriptions that are hard to follow.
This file was last exported: {{{time(%Y-%m-%d %H:%M)}}}

* Getting Started
Put the following in `~/.emacs.d/init.el`:

#+BEGIN_SRC elisp
  ;; keep customized settings in their own file
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; translate the literate configuration and load it.
  (require 'org)

  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC

To make a stylish and sharp Emacs config, write a literate org-mode file using
[[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel.]] Write some text, then put a code block like this:

#+begin_src emacs-lisp :tangle yes
  ;; this is elisp
  (setq my/variable 13)
#+end_src

When you start emacs, =org-babel-load-file= compiles it to elisp by stripping the text
away from the code blocks. Bam! It builds it's own configuration file.

* Emacs Package Management
The first thing to do is setup package managment.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
#+END_SRC

Some of the packages I use get released with breaking changes from time to time,
so it seems prudent to only use the versions hosted by the "stable"
repositories.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'package-pinned-packages '(cider . "melpa") t)
  (add-to-list 'package-pinned-packages '(clj-refactor . "melpa") t)
  (add-to-list 'package-pinned-packages '(rainbow-delimiters . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(magit . "melpa") t)
  (add-to-list 'package-pinned-packages '(ob-http . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(org . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(haskell-mode . "melpa-stable") t)

  (package-initialize)

  (unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defvar smd/packages-to-install
    '(use-package
       avy                            ; because ace-jump-mode is no longer maintained
       popup                          ;
       company                        ;
       smex                           ;
       ido-vertical-mode              ;
       ido-completing-read+           ;
       yasnippet                      ;
       projectile                     ;
       multiple-cursors               ;
       idle-highlight-mode
       highlight-symbol
       highlight-numbers
       highlight-quoted
       org                            ; Life without org-mode is insane
       htmlize
       wc-mode
       flycheck
       flycheck-tip
       flycheck-joker
       flycheck-clj-kondo
       clj-refactor
       clojure-mode
       clojure-mode-extra-font-locking
       cider
       origami
       paredit
       paren-face
       rainbow-delimiters
       ruby-mode
       ruby-test-mode
       inf-ruby
       rbenv
       elisp-slime-nav
       markdown-mode
       markdown-mode+
       yaml-mode
       magit
       forge
       git-gutter
       git-timemachine
       git-annex
       helm
       helm-descbinds
       helm-ag
       helm-projectile
       helm-swoop
       helm-gtags
       helm-ls-git
       helm-flycheck
       helm-flyspell
       helm-flx
       ob-http
       haskell-mode
       typescript-mode))

  (dolist (package smd/packages-to-install)
    (unless (package-installed-p package)
      (package-install package)))
#+end_src

Load [[https://github.com/jwiegley/use-package][use-package]] for loading packages everywhere else. If you set
`use-package-verbose` to `t`, it will debug package loading. What do you think
of this? Does it make things simpler?

#+begin_src emacs-lisp :tangle yes
  (require 'use-package)
  (setq use-package-verbose nil)
#+end_src

* Moving within a buffer
Once upon a time, I used [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]], but it looks to be unmaintained
(or perfect?). Nowadays, there's also [[https://github.com/abo-abo/avy][avy-mode]].

#+begin_src emacs-lisp :tange yes
  (use-package avy
    :ensure t
    :bind (("C-c '" . avy-goto-char)
           ;("C-:" . avy-goto-char)
           ("C-c ;" . avy-goto-char-2)
           ("M-g f" . avy-goto-line)
           ("M-g f" . avy-goto-line))
    :config (progn
              (avy-setup-default)
              (global-set-key (kbd "C-c C-j") 'avy-resume)))
#+end_src

* Using org-mode to keep track of things
** Babel configuration
#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (clojure . t)
   (http . t)))

(setq org-babel-clojure-backend 'cider)
#+end_src
** Basic configuration
I like a `docs/` directory in $HOME, so this is where I keep my org files. I'm
trying out keeping notes in a single file.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/docs/org")
  (setq org-default-notes-file (concat org-directory "/notes.org"))
#+END_SRC

I would like to be able to keep an agenda and get to it quickly.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/docs/org/tasks.org"))
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

We'll mark tasks with a GTD-style set of states.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO" "STARTED" "WAITING" "SOMEDAY" "DONE")))
#+END_SRC

Keep timestamps in a drawer.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer t)
#+END_SRC

[[http://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/][Configure how Org does time clocking on task's state changes]]

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (defun smd/org-clock-in-if-starting ()
         "Clock in when the task is marked STARTED."
         (when (and (string= org-state "STARTED")
                    (not (string= org-last-state org-state)))
           (org-clock-in)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-in-if-starting)
       (defadvice org-clock-in (after smd activate)
         "Set this task's status to 'STARTED'."
         (org-todo "STARTED"))
       (defun smd/org-clock-out-if-waiting ()
         "Clock out when the task is marked WAITING."
         (when (and (string= org-state "WAITING")
                    (equal (marker-buffer org-clock-marker) (current-buffer))
                    (< (point) org-clock-marker)
                    (> (save-excursion (outline-next-heading) (point))
                       org-clock-marker)
                    (not (string= org-last-state org-state)))
           (org-clock-out)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-out-if-waiting)))
#+END_SRC

** Capturing notes quickly
=C-c r= is how I'll capture a thought.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cr" 'org-capture)
  (setq
   org-capture-templates
   '(("h" "hungryllama" entry (file "~/docs/org/hungryllama.org") "")
     ("t" "task" entry
      (file+headline "~/docs/org/tasks.org" "Tasks")
      "* TODO %?" :empty-lines-after 1)
     ("d" "DW" entry
      (file+datetree "~/docs/dw.org")
      "* %?" :empty-lines-after 1)
     ("j" "journal" entry
      (file+datetree "~/docs/org/personal/journal.org")
      "* %?" :empty-lines-after 1)
     ("m" "meetup" entry
      (file+headline "~/docs/org/personal/meetups.org" "Tasks")
      "* %U %?")
     ("" "" entry
      (file "~/org/notes.org")
      "")))
#+END_SRC

** Snippets
I would like to be able to insert code snippets, so let's try yasnippet

#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

** Exporting HTML with Tufte CSS
#+begin_src emacs-lisp :tangle yes
  (defun smd/org-inline-css-hook (exporter)
    "Insert custom inline css. Will try to use tufte css if it
  exists, or style.css in the directory of the file you're working
  on."
    (when (eq exporter 'html)
      (let* ((dir (ignore-errors (file-name-directory (buffer-file-name))))
             (path (concat dir "style.css"))
             (homestyle (or (null dir) (null (file-exists-p path))))
             (final (if homestyle "~/src/tufte-css/tufte.css" path)))
        (setq org-html-head-include-default-style nil)
        (setq org-html-head (concat
                             "<style type=\"text/css\">\n"
                             "<!--/*--><![CDATA[/*><!--*/\n"
                             (with-temp-buffer
                               (insert-file-contents final)
                               (buffer-string))
                             "/*]]>*/-->\n"
                             "</style>\n")))))

  (add-hook 'org-export-before-processing-hook 'smd/org-inline-css-hook)
#+end_src
* Basics and settings used everywhere
Mostly settings that don't fit in elsewhere, so they end up here. However, this
does include settings that aren't part of packages and need to configure Emacs'
built-in packages.

* General settings
Turn on debugging (it will be turned off at the end). In case something happens
during loading that breaks something, it's nice to have debug information.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Don't beep.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda()))
#+END_SRC

Write backup files to own directory and make backups of files even when
they're in version control

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
  (setq vc-make-backup-files t)
#+END_SRC

Always indent, per mode, on newline.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

Dakrone says: "Always, *always*, prefer UTF-8, anything else is insanity."

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode t)
#+END_SRC

Turn off all kinds of modes: I don't need the menu bar, or the tool bar.
Blinking is just horrid.

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC

Show line & column position in your mode-line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Ignore case when using completion for file names

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Don't make me type "yes" at a prompt

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Set up the fill-column to 72 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 72)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

It's okay to refer to a file by a symlink:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename nil)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Uniquify buffers, using angle brackets, so you get =foo= and
=foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Always turn on whitespace mode

#+BEGIN_SRC emacs-lisp
(whitespace-mode t)
#+END_SRC

Indicate trailing empty lines in the GUI, but get rid of them on save. That's
sneaky.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
(setq show-trailing-whitespace t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Let's bind some things to move around buffers easily

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c y") 'bury-buffer)
  (global-set-key (kbd "C-c b") 'revert-buffer)
#+END_SRC

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
  (defvar smd/clojure-prettify-alist '())

  (add-to-list 'smd/clojure-prettify-alist '(">=" . ?≥))
  (add-to-list 'smd/clojure-prettify-alist '("<=" . ?≤))
  (add-to-list 'smd/clojure-prettify-alist '("fn" . ?ƒ))
  (add-to-list 'smd/clojure-prettify-alist '("lambda" . ?λ))

  (eval-after-load 'clojure-mode
    '(setq clojure--prettify-symbols-alist
           (append smd/clojure-prettify-alist
                   clojure--prettify-symbols-alist)))
#+END_SRC

I use rgrep enough that it needs a binding

#+begin_src emacs-lisp
(global-set-key "\C-cg" 'rgrep)
#+end_src

[[http://blog.burntsushi.net/ripgrep/][rigrep]] seems like a neat addition to the search tool arms race

#+begin_src emacs-lisp :tangle yes
(defun rg ()
  (interactive
   (let* ((regexp (read-regexp "Search for" (thing-at-point 'symbol t)))
          (dir (read-directory-name "In directory: " nil default-directory))
          (command (format "rg -H --no-heading \"%s\"" regexp)))
     (with-current-buffer (get-buffer-create "*grep*")
       (cd dir)
       (compilation-start command #'grep-mode nil t)))))

(global-set-key "\C-cG" 'rg)
#+end_src
* Managing Credentials

We can [[https://support.1password.com/command-line-getting-started/][access 1Password vaults from the command line]]. The tool uses
environment variables and has a time-out, so it doesn't play nicely (out
of the box) with Emacs running as a daemon.

#+BEGIN_SRC emacs-lisp
  (defun smd/op-signin ()
    "Unlock a 1Password vault (currently hardcoded) and set the proper ENV"
    (interactive)
    (let* ((pw
            (read-passwd "1password password: "))
           (sessionid
            (shell-command-to-string (concat "echo " pw " | " "op signin democracyworks --raw"))))
      (setenv "OP_SESSION_democracyworks"
              (string-trim sessionid))))
#+END_SRC

* Getting Emacs to play with Tmux in a terminal

Oh, this is somewhat hellish, but there are a few things going on here:

1. You must have the TERM environment setup correctly, to "screen-256color" or so when in Tmux
2. You must have "xterm-keys on" in your Tmux config
3. You "must" do some funky remapping of keys, according to the internet....I hope there's a better way.

#+BEGIN_SRC emacs-lisp
  ;; This is from: https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux

  (if (getenv "TMUX")
      (progn
        (let ((x 2) (tkey ""))
          (while (<= x 8)
            ;; shift
            (if (= x 2)
                (setq tkey "S-"))
            ;; alt
            (if (= x 3)
                (setq tkey "M-"))
            ;; alt + shift
            (if (= x 4)
                (setq tkey "M-S-"))
            ;; ctrl
            (if (= x 5)
                (setq tkey "C-"))
            ;; ctrl + shift
            (if (= x 6)
                (setq tkey "C-S-"))
            ;; ctrl + alt
            (if (= x 7)
                (setq tkey "C-M-"))
            ;; ctrl + alt + shift
            (if (= x 8)
                (setq tkey "C-M-S-"))

            ;; arrows
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d A" x)) (kbd (format "%s<up>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d B" x)) (kbd (format "%s<down>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d C" x)) (kbd (format "%s<right>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d D" x)) (kbd (format "%s<left>" tkey)))
            ;; home
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d H" x)) (kbd (format "%s<home>" tkey)))
            ;; end
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d F" x)) (kbd (format "%s<end>" tkey)))
            ;; page up
            (define-key key-translation-map (kbd (format "M-[ 5 ; %d ~" x)) (kbd (format "%s<prior>" tkey)))
            ;; page down
            (define-key key-translation-map (kbd (format "M-[ 6 ; %d ~" x)) (kbd (format "%s<next>" tkey)))
            ;; insert
            (define-key key-translation-map (kbd (format "M-[ 2 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; delete
            (define-key key-translation-map (kbd (format "M-[ 3 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; f1
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d P" x)) (kbd (format "%s<f1>" tkey)))
            ;; f2
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d Q" x)) (kbd (format "%s<f2>" tkey)))
            ;; f3
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d R" x)) (kbd (format "%s<f3>" tkey)))
            ;; f4
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d S" x)) (kbd (format "%s<f4>" tkey)))
            ;; f5
            (define-key key-translation-map (kbd (format "M-[ 15 ; %d ~" x)) (kbd (format "%s<f5>" tkey)))
            ;; f6
            (define-key key-translation-map (kbd (format "M-[ 17 ; %d ~" x)) (kbd (format "%s<f6>" tkey)))
            ;; f7
            (define-key key-translation-map (kbd (format "M-[ 18 ; %d ~" x)) (kbd (format "%s<f7>" tkey)))
            ;; f8
            (define-key key-translation-map (kbd (format "M-[ 19 ; %d ~" x)) (kbd (format "%s<f8>" tkey)))
            ;; f9
            (define-key key-translation-map (kbd (format "M-[ 20 ; %d ~" x)) (kbd (format "%s<f9>" tkey)))
            ;; f10
            (define-key key-translation-map (kbd (format "M-[ 21 ; %d ~" x)) (kbd (format "%s<f10>" tkey)))
            ;; f11
            (define-key key-translation-map (kbd (format "M-[ 23 ; %d ~" x)) (kbd (format "%s<f11>" tkey)))
            ;; f12
            (define-key key-translation-map (kbd (format "M-[ 24 ; %d ~" x)) (kbd (format "%s<f12>" tkey)))
            ;; f13
            (define-key key-translation-map (kbd (format "M-[ 25 ; %d ~" x)) (kbd (format "%s<f13>" tkey)))
            ;; f14
            (define-key key-translation-map (kbd (format "M-[ 26 ; %d ~" x)) (kbd (format "%s<f14>" tkey)))
            ;; f15
            (define-key key-translation-map (kbd (format "M-[ 28 ; %d ~" x)) (kbd (format "%s<f15>" tkey)))
            ;; f16
            (define-key key-translation-map (kbd (format "M-[ 29 ; %d ~" x)) (kbd (format "%s<f16>" tkey)))
            ;; f17
            (define-key key-translation-map (kbd (format "M-[ 31 ; %d ~" x)) (kbd (format "%s<f17>" tkey)))
            ;; f18
            (define-key key-translation-map (kbd (format "M-[ 32 ; %d ~" x)) (kbd (format "%s<f18>" tkey)))
            ;; f19
            (define-key key-translation-map (kbd (format "M-[ 33 ; %d ~" x)) (kbd (format "%s<f19>" tkey)))
            ;; f20
            (define-key key-translation-map (kbd (format "M-[ 34 ; %d ~" x)) (kbd (format "%s<f20>" tkey)))

            (setq x (+ x 1))))))
#+END_SRC
* A Terminal in Emacs

Use =zsh= as the default shell (it would be nice to not have to press
=RET= to confirm the default, though.)

#+begin_src emacs-lisp :tangle yes
  (setq explicit-shell-file-name "/bin/zsh")
#+end_src

How do you switch modes again, Chris?

#+begin_src emacs-lisp :tangle yes
  (add-hook 'term-mode-hook '(lambda ()
    (setq mode-line-format
      (list
       " "
       '(:eval (propertize "%b "))
       "("
       '(:eval (propertize "%m "))
       '(:eval (if (term-in-char-mode)
                   "char) [C-x C-j to switch]"
                   "line) [C-c C-k to switch]"))))))
#+end_src

* SMEX

[[https://github.com/nonsequitur/smex/][Smex is a M-x enhancement for Emacs.]]

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :bind (("M-x" . smex)
           ("M-X" . smex-major-mode-commands)
           ("C-c C-c M-x" . execute-extended-command))
    :config (smex-initialize))
#+END_SRC

* ido-mode everywhere

Use ido-mode everywhere! See https://www.masteringemacs.org/article/introduction-to-ido-mode

#+BEGIN_SRC emacs-lisp
  (require 'ido-vertical-mode)
  (require 'ido-completing-read+)

  (ido-mode 1)
  (ido-everywhere 1)
  (ido-ubiquitous-mode 1)
  (ido-vertical-mode 1)

  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
  (setq ido-enable-flex-matching t)
  (setq ido-create-new-buffer 'always)
#+END_SRC

* Saveplace
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

* Multiple Cursors

I like this, having learned about it in Sublime Text and the IntelliJ family of editors.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-c e"        . mc/edit-lines)
           ("C-<down>"     . mc/mark-next-like-this)
           ("C-<up>"       . mc/mark-previous-like-this)
           ("C-c C-<down>" . mc/mark-all-like-this)))


  ;(require 'multiple-cursors)

  ;(global-set-key (kbd "C-c e") 'mc/edit-lines)
  ;(global-set-key (kbd "C-<down>") 'mc/mark-next-like-this)
  ;(global-set-key (kbd "C-<up>") 'mc/mark-previous-like-this)
  ;(global-set-key (kbd "C-c C-<down>") 'mc/mark-all-like-this)
#+END_SRC

* Version Control
I use git for most of my version control needs, and it's nice to use [[http://magit.vc/][Magit]] and
not leave Emacs pretty well. Most of the interactions comes from two functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

When branching from a branch from a branch, tracking gets a little weird; don't
set it by default, but let me tell you what I want it to be. According to
[[https://github.com/tie-rack/emacs.d/blob/master/tierack.org#magit][tie-rack's settings]] around 2.1, you could do something like this

#+begin_src emacs-lisp
  ;; (setq magit-branch-arguments (remove "--track" magit-branch-arguments))
#+end_src

It looks like as of version 2.5.0 [[http://magit.vc/manual/magit/Branching.html#Branching][branching behavior]] has changed (again), and
you can use =magit-branch-spinoff= to do a similar thing:

"This command creates and checks out a new branch starting at and tracking the
current branch. That branch in turn is reset to the last commit it shares with
its upstream. If the current branch has no upstream or no unpushed commits, then
the new branch is created anyway and the previously current branch is not
touched.

This is useful to create a feature branch after work has already began on the
old branch (likely but not necessarily "master")."

* Programming Modes
(In Emacs, most programming language modes derive from prog-mode; any hooks
created for prog-mode should apply to all language modes.) Subword mode lets me
move between SegmentsOfACamelCasedThing and idle-highlight-mode will hightlight
the word under the point.

#+BEGIN_SRC emacs-lisp
  (use-package idle-highlight-mode
    :init
    (progn
      (defun smd/idle-highlight-hook ()
        (interactive)
        (when (fboundp 'idle-highlight-mode)
          (idle-highlight-mode t))
        (setq show-trailing-whitespace t)
        (subword-mode t))

      (add-hook 'prog-mode-hook #'smd/idle-highlight-hook)))
#+END_SRC

FIXME and TODO can be highlighted so they stand out

#+BEGIN_SRC emacs-lisp
  (defun smd/add-watchwords ()
    "Highlight FIXME, TODO, and NOCOMMIT in code"
    (font-lock-add-keywords
     nil '(("\\<\\(FIXME\\|TODO\\|NOCOMMIT\\)\\>"
            1 '((:foreground "#d7d7d7") (:weight bold)) t))))

  (add-hook 'prog-mode-hook 'smd/add-watchwords)
#+END_SRC

Display parentheses nicely

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  (set-face-background 'show-paren-match "red")
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

* Paredit
Paredit for all the lisps

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish "()"
    :config
    (progn
      (define-key paredit-mode-map (kbd "M-)") 'paredit-forward-slurp-sexp)
      (define-key paredit-mode-map (kbd "M-(") 'paredit-forward-barf-sexp)
      (define-key paredit-mode-map (kbd ")")   'paredit-close-parenthesis)))

#+END_SRC

* Clojure

Running =(cider-jack-in)= is sometimes enough, but when you need to jack-in with
a specific profile, it should be easy.

#+BEGIN_SRC emacs-lisp
  (defun smd/cider-jack-in-test-profile ()
    (interactive)
    (let ((cider-lein-parameters (concat "with-profile +test "
                                         cider-lein-parameters)))
      (cider-jack-in)))
#+END_SRC

When working on Clojurescript projects that are setup for Figwheel, running
=(cider-jack-in-clojurescript)= will launch both a Clojure and a Clojurescript
REPL. Once they come up, you can start a Figwheel session with =C-c C-f=.

#+BEGIN_SRC emacs-lisp
  (defun smd/cider-figwheel-repl ()
    (interactive)
    (save-some-buffers)
    (with-current-buffer (cider-current-repl-buffer)
      (goto-char (point-max))
      (insert "(require 'figwheel-sidecar.repl-api)
               (figwheel-sidecar.repl-api/start-figwheel!) ; idempotent
               (figwheel-sidecar.repl-api/cljs-repl)")
      (cider-repl-return)))
#+END_SRC

Sometimes it is nice to send a form to the repl and evaluate it.

#+BEGIN_SRC emacs-lisp
  (defun smd/cider-send-to-repl ()
    (interactive)
    (let ((s (buffer-substring-no-properties
              (nth 0 (cider-last-sexp 'bounds))
              (nth 1 (cider-last-sexp 'bounds)))))
      (with-current-buffer (cider-current-connection)
        (insert s)
        (cider-repl-return))))
#+END_SRC

CIDER is pretty easy to setup. Cider is also pretty easy to homebrew.

#+BEGIN_SRC emacs-lisp
  (defun smd/setup-cider ()
    (interactive)
    (paredit-mode 1)
    (eldoc-mode 1)
    (setq cider-history-file "~/.nrepl-history"
          cider-hide-special-buffers t
          cider-repl-display-help-banner nil
          cider-repl-history-size 10000
          cider-prefer-local-resources t
          cider-popup-stacktraces-in-repl t
          nrepl-log-messages nil
          paredit-mode t
          company-mode t
          cider-repl-history-file "~/.cider-repl.log")

    (setq cider-cljs-lein-repl
          "(do (require 'figwheel-sidecar.repl-api)
             (figwheel-sidecar.repl-api/start-figwheel!)
             (figwheel-sidecar.repl-api/cljs-repl))"))

  (use-package cider
    :init
    (add-hook #'cider-mode-hook #'smd/setup-cider)
    (add-hook #'cider-repl-mode-hook #'smd/setup-cider)
    :bind (("C-c C-f" . smd/cider-figwheel-repl)
           ("C-c C-s ." . smd/cider-send-to-repl)
           ("M-TAB"   . company-complete)))
#+END_SRC

=company= makes autocompletion sort of work.
=paredit= and =rainbow-delimiters= make the parentheses pretty nice.
=eldoc= shows you the docstring of a function in the echo area.

Korma functions are going to get pretty nested, so
let's not indent them too much.

#+BEGIN_SRC emacs-lisp
  (defun smd/korma-indentation ()
    (define-clojure-indent
      (korma/select 1)
      (korma/where 1)
      (korma/insert 1)
      (korma/delete 1)
      (korma/join 1)
      (korma/update 1)))

  (defun smd/clojure-mode-hook ()
    (cljr-add-keybindings-with-prefix "C-c C-m")
    (rainbow-delimiters-mode t)
    (projectile-mode 1)
    (linum-mode 1)
    (paredit-mode 1)
    (company-mode 1)
    (smd/korma-indentation))

  (use-package clojure-mode
    :config (progn
             (use-package cider)
             (use-package clj-refactor)
             (use-package eldoc)
             (use-package company)
             (use-package paredit)
             (use-package projectile)
             (add-hook 'clojure-mode-hook 'smd/clojure-mode-hook))
    :bind (("C-c w" . paredit-copy-as-kill)
           ("C-c j" . smd/cider-jack-in-test-profile)
           ("C-c i" . imenu)
           ("C-c C-l" . cider-repl-clear-buffer)))
#+END_SRC

* SQL things
Sometimes you need to use a relational database for some. Since I tend to use
PostgreSQL, we need to setup sql-postgres

#+begin_src emacs-lisp :tangle yes
  (setq sql-postgres-login-params
        '((user :default "smd")
          (database :default "postgres")
          (server :default "localhost")
          (port :default 5432)))
#+end_src

"PostgreSQL databases with underscores in their names trip up the prompt
specified in sql.el. I work around this with the following. Warning, this sets
the prompt globally, which is fine by me since I only ever use Postgres."
-- [[https://www.emacswiki.org/emacs/SqlMode][EmacsWiki - SqlMode]]

#+begin_src emacs-lisp :tangle yes
(add-hook 'sql-interactive-mode-hook
            (lambda ()
              (setq sql-prompt-regexp "^[_[:alpha:]]*[=][#>] ")
              (setq sql-prompt-cont-regexp "^[_[:alpha:]]*[-][#>] ")))
#+end_src
* Projectile
Always use Projectile because turning it on for specific things is annoying.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init (setq projectile-keymap-prefix (kbd "C-c C-p"))
    :config (projectile-global-mode))
#+END_SRC

* Snippets

Yasnippet can be setup with a pretty big collection of templates

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-=") 'yas-insert-snippet)

  ;; (setq yas-snippet-dirs
  ;;       '("~/.emacs.d/snippets"                 ;; personal snippets
  ;;         "/path/to/some/collection/"           ;; foo-mode and bar-mode snippet collection
  ;;         "/path/to/yasnippet/yasmate/snippets" ;; the yasmate collection
  ;;         "/path/to/yasnippet/snippets"         ;; the default collection
  ;;         ))

  (yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet already.
#+END_SRC

I can make a geojson snippet with this:

#+begin_src javascript
  {
      "type": "Feature",
      "properties": {
          "name": "Janet's Cabin",
          "amenity": "Gas, electric lights, multiple rooms, ",
          "comments": "This is the first hut the Mo and I visited. It was a learning experience."
      },
      "geometry": {
          "type": "Point",
          "coordinates": [-104.99404, 39.75621]
      }
  }
#+end_src

* Javascript
Sometimes we have to write Javascript. I guess that's that, so let's try and
make it a little more _sane_, ok?

#+begin_src emacs-lisp :tangle yes
  (setq-default js-indent-indent 2)
#+end_src
* Java
[[https://github.com/emacs-lsp/lsp-java][lsp-java]] provides integration with the Eclipse JDT Language Server. This
makes doing IDE-like things with Java much nicer inside Emacs.

Here's a minimal configuration from the project's README. First, get the latest JDT.

#+BEGIN_EXAMPLE
  rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
  mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
  wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
  tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cc-mode)

  ;; (use-package treemacs
  ;;   :ensure t)

  (use-package lsp-mode
    :ensure t
    :init (setq lsp-inhibit-message t
                lsp-eldoc-render-all t
                lsp-highlight-symbol-at-point t))

  (use-package company-lsp
    :after  company
    :ensure t
    :config
    (add-hook 'java-mode-hook (lambda () (push 'company-lsp company-backends)))
    (setq company-lsp-enable-snippet t
          company-lsp-cache-candidates t)
    (push 'java-mode company-global-modes))

  (use-package lsp-ui
    :ensure t
    :config
    (setq lsp-ui-doc-enable t
          lsp-ui-doc-position 'top
          lsp-ui-doc-use-childframe t
          lsp-ui-flycheck-list-position 'bottom
          lsp-ui-flycheck-live-reporting t
          lsp-ui-imenu-enable nil
          lsp-ui-peek-enable t
          lsp-ui-peek-always-show t
          lsp-ui-sideline-enable t
          lsp-ui-sideline-show-symbol nil
          lsp-ui-sideline-show-hover nil
          lsp-ui-sideline-show-code-actions nil
          lsp-ui-sideline-show-flycheck t
          lsp-ui-sideline-ignore-duplicate t
          lsp-ui-sideline-update-mode 'line))

  (use-package lsp-java
    :ensure t
    :requires (lsp-ui-flycheck lsp-ui-sideline)
    :init (setq
           lsp-java-organize-imports nil
           lsp-java-save-action-organize-imports nil)
    :config
    (add-hook 'java-mode-hook  'lsp-java-enable)
    (add-hook 'java-mode-hook  'dap-mode)
    (add-hook 'java-mode-hook  'flycheck-mode)
    (add-hook 'java-mode-hook  'company-mode)
    (add-hook 'java-mode-hook  'rainbow-delimiters-mode)
    (add-hook 'java-mode-hook  'linum-mode)
    (setq lsp-java--workspace-folders
          (list "/Users/smd/src/democracyworks/colorado-rla/server/eclipse-project/")))

  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t))

  (use-package dap-java
    :after (lsp-java))

  ;; (use-package lsp-java-treemacs
  ;;   :after (treemacs))
#+end_src

* Typescript

First, we should enable Typescript mode for the right  things

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package typescript-mode
    :ensure t
    :init (setq lsp-inhibit-message nil
                lsp-eldoc-render-all t
                lsp-highlight-symbol-at-point t))
#+end_src

* Finally
Turn off debugging now that initialization is done.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC
