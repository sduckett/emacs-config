#+TITLE:   The Ever Growing Emacs Configuration
#+AUTHOR:  Sean Duckett
#+EMAIL:   sean@hungryllama.net
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

* Introduction

This is the emacs config that I use. It isn't doom emacs or spacemacs or
trying to be either. But it is pretty fun to hack on elisp! It was based
on Dakrone's emacs config, influenced by cms's emacs config, and ever
adjusted. Even still, there are spots where I've forgotten if I still
use that mode a lot. This file was last exported: {{{time(%Y-%m-%d
%H:%M)}}}

* Installation

Put the following in `$HOME/.emacs.d/init.el`. Notice that we're not
tangling it, so it won't appear in the output.

#+BEGIN_SRC elisp :tangle no
  ;; keep customized settings in their own file
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; translate the literate configuration and load it.
  (require 'org)

  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC

To make a stylish and sharp Emacs config, write a literate org-mode file using
[[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel.]] Write some text, then put a code block like this:

#+begin_src emacs-lisp :tangle yes
  ;; this is elisp
  (setq my/variable 13)
#+end_src

When you start emacs, =org-babel-load-file= compiles it to elisp by stripping the text
away from the code blocks. Bam! It builds its own configuration file.

* Package Management
The first thing to do is setup package managment.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  ;; (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
#+END_SRC

Some of the packages I use get released with breaking changes from time to time,
so it seems prudent to only use the versions hosted by the "stable"
repositories.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(clj-refactor . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(rainbow-delimiters . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(magit . "melpa") t)
  (add-to-list 'package-pinned-packages '(ob-http . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(org . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(haskell-mode . "melpa-stable") t)

  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defvar smd/packages-to-install
    '(use-package
       avy                            ; for jump-to-char tooling
       csv-mode                       ; what it says on the tin
       popup                          ;
       company                        ;
       smex                           ;
       ido-vertical-mode              ;
       ido-completing-read+           ;
       yasnippet                      ;
       projectile                     ;
       multiple-cursors               ;
       idle-highlight-mode
       highlight-symbol
       highlight-numbers
       highlight-quoted
       org                            ; Life without org-mode is insane
       htmlize
       wc-mode
       flycheck
       flycheck-tip
       flycheck-joker
       flycheck-clj-kondo
       clj-refactor
       clojure-mode
       clojure-mode-extra-font-locking
       cider
       origami
       paredit
       ;;paren-face
       rainbow-delimiters
       ruby-mode
       ruby-test-mode
       inf-ruby
       rbenv
       elisp-slime-nav
       markdown-mode
       yaml-mode
       magit
       git-gutter
       git-timemachine
       git-annex
       helm
       helm-descbinds
       helm-ag
       helm-projectile
       helm-swoop
       helm-gtags
       helm-ls-git
       helm-flycheck
       helm-flyspell
       helm-flx
       ob-http
       haskell-mode
       window-numbering))

  (dolist (package smd/packages-to-install)
    (unless (package-installed-p package)
      (package-install package)))
#+end_src

Load [[https://github.com/jwiegley/use-package][use-package]] for loading packages everywhere else. If you set
`use-package-verbose` to `t`, it will debug package loading. What do you think
of this? Does it make things simpler?

#+begin_src emacs-lisp :tangle yes
  (require 'use-package)
  (setq use-package-verbose nil)
#+end_src

* Moving within a buffer
Once upon a time, I used [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]], but it looks to be unmaintained
(or perfect?). Nowadays, there's also [[https://github.com/abo-abo/avy][avy-mode]].

#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :ensure t
    :bind (("C-c '" . avy-goto-char)
           ;("C-:" . avy-goto-char)
           ("C-c ;" . avy-goto-char-2)
           ("M-g f" . avy-goto-line)
           ("M-g f" . avy-goto-line))
    :config (progn
              (avy-setup-default)
              (global-set-key (kbd "C-c C-j") 'avy-resume)))
#+end_src

* Using org-mode to keep track of things
** Babel configuration
I'm interested in using Babel for =emacs-lisp=, =clojure=, and =http=
(i.e., cUrl from org-mode).

#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (clojure . t)
   (http . t)))

(setq org-babel-clojure-backend 'cider)
#+end_src

** Org configuration

I like a `docs/` directory in $HOME, so this is where I keep my org files. I'm
trying out keeping notes in a single file.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/docs/org")
  (setq org-default-notes-file (concat org-directory "/notes.org"))
#+END_SRC

I would like to be able to keep an agenda and get to it quickly with =C-c a=.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/docs/org/tasks.org"))
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

We'll mark tasks with a GTD-style set of states.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO" "STARTED" "WAITING" "SOMEDAY" "DONE")))
#+END_SRC

Keep timestamps in a drawer.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer t)
#+END_SRC

[[http://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/][Configure how Org does time clocking on task's state changes]]

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (defun smd/org-clock-in-if-starting ()
         "Clock in when the task is marked STARTED."
         (when (and (string= org-state "STARTED")
                    (not (string= org-last-state org-state)))
           (org-clock-in)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-in-if-starting)
       (defadvice org-clock-in (after smd activate)
         "Set this task's status to 'STARTED'."
         (org-todo "STARTED"))
       (defun smd/org-clock-out-if-waiting ()
         "Clock out when the task is marked WAITING."
         (when (and (string= org-state "WAITING")
                    (equal (marker-buffer org-clock-marker) (current-buffer))
                    (< (point) org-clock-marker)
                    (> (save-excursion (outline-next-heading) (point))
                       org-clock-marker)
                    (not (string= org-last-state org-state)))
           (org-clock-out)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-out-if-waiting)))
#+END_SRC

** Capturing notes quickly
=C-c r= is how I'll capture a thought.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cr" 'org-capture)
  (setq
   org-capture-templates
   '(("h" "hungryllama" entry (file "~/docs/org/hungryllama.org") "")
     ("t" "task" entry
      (file+headline "~/docs/org/tasks.org" "Tasks")
      "* TODO %?" :empty-lines-after 1)
     ("s" "Standups" entry
      (file+datetree "~/docs/standups.org")
      "* %?" :empty-lines-after 1)
     ("j" "journal" entry
      (file+datetree "~/docs/org/personal/journal.org")
      "* %?" :empty-lines-after 1)
     ("m" "meetup" entry
      (file+headline "~/docs/org/personal/meetups.org" "Tasks")
      "* %U %?")
     ("" "" entry
      (file "~/org/notes.org")
      "")))
#+END_SRC

** Snippets
I would like to be able to insert code snippets, so let's try yasnippet

#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

** Exporting HTML with Tufte CSS
#+begin_src emacs-lisp :tangle yes
  (defun smd/org-inline-css-hook (exporter)
    "Insert custom inline css. Will try to use tufte css if it
  exists, or style.css in the directory of the file you're working
  on."
    (when (eq exporter 'html)
      (let* ((dir (ignore-errors (file-name-directory (buffer-file-name))))
             (path (concat dir "style.css"))
             (homestyle (or (null dir) (null (file-exists-p path))))
             (final (if homestyle "~/src/tufte-css/tufte.css" path)))
        (setq org-html-head-include-default-style nil)
        (setq org-html-head (concat
                             "<style type=\"text/css\">\n"
                             "<!--/*--><![CDATA[/*><!--*/\n"
                             (with-temp-buffer
                               (insert-file-contents final)
                               (buffer-string))
                             "/*]]>*/-->\n"
                             "</style>\n")))))

  (add-hook 'org-export-before-processing-hook 'smd/org-inline-css-hook)
#+end_src
* General settings
Turn on debugging (it will be turned off at the end). In case something happens
during loading that breaks something, it's nice to have debug information.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Don't beep.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda()))
#+END_SRC

Write backup files to own directory and make backups of files even when
they're in version control

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
  (setq vc-make-backup-files t)
#+END_SRC

Always indent, per mode, on newline.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

Dakrone says: "Always, *always*, prefer UTF-8, anything else is insanity."

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode t)
#+END_SRC

Turn off all kinds of modes: I don't need the menu bar, or the tool bar.
Blinking is just horrid.

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC

Show line & column position in your mode-line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Ignore case when using completion for file names

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Don't make me type "yes" at a prompt

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Set up the fill-column to 72 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 72)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

It's okay to refer to a file by a symlink:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename nil)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Uniquify buffers, using angle brackets, so you get =foo= and
=foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Always turn on whitespace mode

#+BEGIN_SRC emacs-lisp
(whitespace-mode t)
#+END_SRC

Indicate trailing empty lines in the GUI, but get rid of them on save. That's
sneaky.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
(setq show-trailing-whitespace t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Let's bind some things to move around buffers easily

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c y") 'bury-buffer)
  (global-set-key (kbd "C-c b") 'revert-buffer)
#+END_SRC

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
  (defvar smd/clojure-prettify-alist '())

  (add-to-list 'smd/clojure-prettify-alist '(">=" . ?≥))
  (add-to-list 'smd/clojure-prettify-alist '("<=" . ?≤))
  (add-to-list 'smd/clojure-prettify-alist '("fn" . ?ƒ))
  (add-to-list 'smd/clojure-prettify-alist '("lambda" . ?λ))

  (eval-after-load 'clojure-mode
    '(setq clojure--prettify-symbols-alist
           (append smd/clojure-prettify-alist
                   clojure--prettify-symbols-alist)))
#+END_SRC

I use rgrep enough that it needs a binding

#+begin_src emacs-lisp
(global-set-key "\C-cg" 'rgrep)
#+end_src

[[http://blog.burntsushi.net/ripgrep/][rigrep]] seems like a neat addition to the search tool arms race

#+begin_src emacs-lisp :tangle yes
(defun rg ()
  (interactive
   (let* ((regexp (read-regexp "Search for" (thing-at-point 'symbol t)))
          (dir (read-directory-name "In directory: " nil default-directory))
          (command (format "rg -H --no-heading \"%s\"" regexp)))
     (with-current-buffer (get-buffer-create "*grep*")
       (cd dir)
       (compilation-start command #'grep-mode nil t)))))

(global-set-key "\C-cG" 'rg)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (global-set-key "\C-ci" 'imenu)
#+end_src
* Managing Credentials

We can [[https://support.1password.com/command-line-getting-started/][access 1Password vaults from the command line]]. The tool uses
environment variables and has a time-out, so it doesn't play nicely (out
of the box) with Emacs running as a daemon.

#+BEGIN_SRC emacs-lisp
  (defun smd/op-signin ()
    "Unlock a 1Password vault (currently hardcoded) and set the proper ENV"
    (interactive)
    (let* ((pw
            (read-passwd "1password password: "))
           (sessionid
            (shell-command-to-string (concat "echo " pw " | " "op signin democracyworks --raw"))))
      (setenv "OP_SESSION_democracyworks"
              (string-trim sessionid))))
#+END_SRC

* Getting Emacs to play with Tmux in a terminal

Oh, this is somewhat hellish, but there are a few things going on here:

1. You must have the TERM environment setup correctly, to "screen-256color" or so when in Tmux
2. You must have "xterm-keys on" in your Tmux config
3. You "must" do some funky remapping of keys, according to the internet....I hope there's a better way.

#+BEGIN_SRC emacs-lisp
  ;; This is from: https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux

  (if (getenv "TMUX")
      (progn
        (let ((x 2) (tkey ""))
          (while (<= x 8)
            ;; shift
            (if (= x 2)
                (setq tkey "S-"))
            ;; alt
            (if (= x 3)
                (setq tkey "M-"))
            ;; alt + shift
            (if (= x 4)
                (setq tkey "M-S-"))
            ;; ctrl
            (if (= x 5)
                (setq tkey "C-"))
            ;; ctrl + shift
            (if (= x 6)
                (setq tkey "C-S-"))
            ;; ctrl + alt
            (if (= x 7)
                (setq tkey "C-M-"))
            ;; ctrl + alt + shift
            (if (= x 8)
                (setq tkey "C-M-S-"))

            ;; arrows
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d A" x)) (kbd (format "%s<up>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d B" x)) (kbd (format "%s<down>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d C" x)) (kbd (format "%s<right>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d D" x)) (kbd (format "%s<left>" tkey)))
            ;; home
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d H" x)) (kbd (format "%s<home>" tkey)))
            ;; end
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d F" x)) (kbd (format "%s<end>" tkey)))
            ;; page up
            (define-key key-translation-map (kbd (format "M-[ 5 ; %d ~" x)) (kbd (format "%s<prior>" tkey)))
            ;; page down
            (define-key key-translation-map (kbd (format "M-[ 6 ; %d ~" x)) (kbd (format "%s<next>" tkey)))
            ;; insert
            (define-key key-translation-map (kbd (format "M-[ 2 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; delete
            (define-key key-translation-map (kbd (format "M-[ 3 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; f1
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d P" x)) (kbd (format "%s<f1>" tkey)))
            ;; f2
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d Q" x)) (kbd (format "%s<f2>" tkey)))
            ;; f3
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d R" x)) (kbd (format "%s<f3>" tkey)))
            ;; f4
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d S" x)) (kbd (format "%s<f4>" tkey)))
            ;; f5
            (define-key key-translation-map (kbd (format "M-[ 15 ; %d ~" x)) (kbd (format "%s<f5>" tkey)))
            ;; f6
            (define-key key-translation-map (kbd (format "M-[ 17 ; %d ~" x)) (kbd (format "%s<f6>" tkey)))
            ;; f7
            (define-key key-translation-map (kbd (format "M-[ 18 ; %d ~" x)) (kbd (format "%s<f7>" tkey)))
            ;; f8
            (define-key key-translation-map (kbd (format "M-[ 19 ; %d ~" x)) (kbd (format "%s<f8>" tkey)))
            ;; f9
            (define-key key-translation-map (kbd (format "M-[ 20 ; %d ~" x)) (kbd (format "%s<f9>" tkey)))
            ;; f10
            (define-key key-translation-map (kbd (format "M-[ 21 ; %d ~" x)) (kbd (format "%s<f10>" tkey)))
            ;; f11
            (define-key key-translation-map (kbd (format "M-[ 23 ; %d ~" x)) (kbd (format "%s<f11>" tkey)))
            ;; f12
            (define-key key-translation-map (kbd (format "M-[ 24 ; %d ~" x)) (kbd (format "%s<f12>" tkey)))
            ;; f13
            (define-key key-translation-map (kbd (format "M-[ 25 ; %d ~" x)) (kbd (format "%s<f13>" tkey)))
            ;; f14
            (define-key key-translation-map (kbd (format "M-[ 26 ; %d ~" x)) (kbd (format "%s<f14>" tkey)))
            ;; f15
            (define-key key-translation-map (kbd (format "M-[ 28 ; %d ~" x)) (kbd (format "%s<f15>" tkey)))
            ;; f16
            (define-key key-translation-map (kbd (format "M-[ 29 ; %d ~" x)) (kbd (format "%s<f16>" tkey)))
            ;; f17
            (define-key key-translation-map (kbd (format "M-[ 31 ; %d ~" x)) (kbd (format "%s<f17>" tkey)))
            ;; f18
            (define-key key-translation-map (kbd (format "M-[ 32 ; %d ~" x)) (kbd (format "%s<f18>" tkey)))
            ;; f19
            (define-key key-translation-map (kbd (format "M-[ 33 ; %d ~" x)) (kbd (format "%s<f19>" tkey)))
            ;; f20
            (define-key key-translation-map (kbd (format "M-[ 34 ; %d ~" x)) (kbd (format "%s<f20>" tkey)))

            (setq x (+ x 1))))))
#+END_SRC
* A Terminal in Emacs

Use =zsh= as the default shell (it would be nice to not have to press
=RET= to confirm the default, though.)

#+begin_src emacs-lisp :tangle yes
  (setq explicit-shell-file-name "/bin/zsh")
#+end_src

How do you switch modes again, Chris?

#+begin_src emacs-lisp :tangle yes
  (add-hook 'term-mode-hook '(lambda ()
    (setq mode-line-format
      (list
       " "
       '(:eval (propertize "%b "))
       "("
       '(:eval (propertize "%m "))
       '(:eval (if (term-in-char-mode)
                   "char) [C-x C-j to switch]"
                   "line) [C-c C-k to switch]"))))))
#+end_src

* SMEX

[[https://github.com/nonsequitur/smex/][Smex is a M-x enhancement for Emacs.]]

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :bind (("M-x" . smex)
           ("M-X" . smex-major-mode-commands)
           ("C-c C-c M-x" . execute-extended-command))
    :config (smex-initialize))
#+END_SRC

* ido-mode everywhere

Use ido-mode everywhere! See https://www.masteringemacs.org/article/introduction-to-ido-mode

#+BEGIN_SRC emacs-lisp
  (require 'ido-vertical-mode)
  (require 'ido-completing-read+)

  (ido-mode 1)
  (ido-everywhere 1)
  (ido-ubiquitous-mode 1)
  (ido-vertical-mode 1)

  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
  (setq ido-enable-flex-matching t)
  (setq ido-create-new-buffer 'always)
#+END_SRC

* Saveplace
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (save-place-mode 1)
    :config
    (setq save-place-file
          (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

* Multiple Cursors

I like this, having learned about it in Sublime Text and the IntelliJ family of editors.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-c e"        . mc/edit-lines)
           ("C-<down>"     . mc/mark-next-like-this)
           ("C-<up>"       . mc/mark-previous-like-this)
           ("C-c C-<down>" . mc/mark-all-like-this)))


  ;(require 'multiple-cursors)

  ;(global-set-key (kbd "C-c e") 'mc/edit-lines)
  ;(global-set-key (kbd "C-<down>") 'mc/mark-next-like-this)
  ;(global-set-key (kbd "C-<up>") 'mc/mark-previous-like-this)
  ;(global-set-key (kbd "C-c C-<down>") 'mc/mark-all-like-this)
#+END_SRC

* Version Control
I use git for most of my version control needs, and it's nice to use [[http://magit.vc/][Magit]] and
not leave Emacs pretty well. Most of the interactions comes from two functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

When branching from a branch from a branch, tracking gets a little weird; don't
set it by default, but let me tell you what I want it to be. According to
[[https://github.com/tie-rack/emacs.d/blob/master/tierack.org#magit][tie-rack's settings]] around 2.1, you could do something like this

#+begin_src emacs-lisp
  ;; (setq magit-branch-arguments (remove "--track" magit-branch-arguments))
#+end_src

It looks like as of version 2.5.0 [[http://magit.vc/manual/magit/Branching.html#Branching][branching behavior]] has changed (again), and
you can use =magit-branch-spinoff= to do a similar thing:

"This command creates and checks out a new branch starting at and tracking the
current branch. That branch in turn is reset to the last commit it shares with
its upstream. If the current branch has no upstream or no unpushed commits, then
the new branch is created anyway and the previously current branch is not
touched.

This is useful to create a feature branch after work has already began on the
old branch (likely but not necessarily "master")."

* Fun with Timestamps
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ts)

  (defun smd/ts-at-point ()
    (unless (looking-at "[0-9.]")
      nil)
    (let ((origin (point))
          beg end)
      (save-excursion
        (setq beg (+ origin (skip-chars-backward "0123456789."))))
      (save-excursion
        (setq end (+ origin (skip-chars-forward "0123456789."))))
      (list beg end)))

  (defun smd/show-date-at-point ()
    (interactive)
    (let* ((r (smd/ts-at-point))
           (beg (nth 0 r))
           (end (nth 1 r))
           (unix_ts (buffer-substring beg end)))
      (message (ts-format (make-ts :unix (float (read unix_ts)))))))

#+END_SRC
* Programming Modes
(In Emacs, most programming language modes derive from prog-mode; any hooks
created for prog-mode should apply to all language modes.) Subword mode lets me
move between SegmentsOfACamelCasedThing and idle-highlight-mode will hightlight
the word under the point.

#+BEGIN_SRC emacs-lisp
  (use-package idle-highlight-mode
    :init
    (progn
      (defun smd/idle-highlight-hook ()
        (interactive)
        (when (fboundp 'idle-highlight-mode)
          (idle-highlight-mode t))
        (setq show-trailing-whitespace t)
        (subword-mode t))

      (add-hook 'prog-mode-hook #'smd/idle-highlight-hook)))
#+END_SRC

FIXME and TODO can be highlighted so they stand out

#+BEGIN_SRC emacs-lisp
  (defun smd/add-watchwords ()
    "Highlight FIXME, TODO, and NOCOMMIT in code"
    (font-lock-add-keywords
     nil '(("\\<\\(FIXME\\|TODO\\|NOCOMMIT\\)\\>"
            1 '((:foreground "#d7d7d7") (:weight bold)) t))))

  (add-hook 'prog-mode-hook 'smd/add-watchwords)
#+END_SRC

Display parentheses nicely

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  ;;(set-face-background 'show-paren-match "red")
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

* XML Management
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package xml-format
    :demand t
    :after nxml-mode)
#+END_SRC
* Programming Without Typing

Talonvoice is pretty neat software and there are many good tools for
driving editors. One such example is Cursorless, but that is designed to
work with VSCode. To get something similar in Emacs, we have some other
options (which are largely in development).

#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path "/Users/sean/repos/github.com/sduckett/hatty.el")
  ;; (require 'hatty)
  ;; (global-hatty-mode 1)
#+END_SRC

* Paredit
Paredit for all the lisps

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit
    :ensure t
    :diminish "()"
    :hook ((emacs-lisp-mode clojure-mode) . paredit-mode)
    :bind (:map paredit-mode-map
                ("M-(" . paredit-forward-barf-sexp)
                ("M-)" . paredit-forward-slurp-sexp)
                (")" . paredit-close-parenthesis)
                ("C-c w" . paredit-copy-as-kill)
                ("RET" . nil)))
#+END_SRC

* LSP

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package lsp-mode
      :ensure t
      :init (setq lsp-inhibit-message t
                  lsp-eldoc-render-all t
                  lsp-highlight-symbol-at-point t
                  lsp-enable-indentation nil
                  lsp-enable-completion-at-point nil
                  gc-cons-threshold (* 100 1024 1024)
                  read-process-output-max (* 1024 1024)
                  treemacs-space-between-root-nodes nil
                  company-minimum-prefix-length 1))

    (use-package lsp-ui
      :ensure t
      :config
      (setq lsp-lens-enable nil
            lsp-ui-doc-enable nil
            lsp-ui-doc-position 'top
            lsp-ui-doc-use-childframe t
            lsp-ui-flycheck-list-position 'bottom
            lsp-ui-flycheck-live-reporting t
            lsp-ui-imenu-enable nil
            lsp-ui-peek-enable t
            lsp-ui-peek-always-show nil
            lsp-ui-sideline-enable t
            lsp-ui-sideline-show-symbol nil
            lsp-ui-sideline-show-hover nil
            lsp-ui-sideline-show-code-actions nil
            lsp-ui-sideline-show-flycheck t
            lsp-ui-sideline-ignore-duplicate t
            lsp-ui-sideline-update-mode 'line))

#+END_SRC

* Clojure

Running =(cider-jack-in)= is sometimes enough, but when you need to
jack-in with a specific profile, it should be easy.

#+BEGIN_SRC emacs-lisp :tangle yes
    (defun smd/cider-jack-in-test-profile ()
      (interactive)
      (let ((cider-lein-parameters (concat "with-profile +test "
                                          cider-lein-parameters)))
        (set-variable 'cider-lein-parameters cider-lein-parameters)
        (cider-jack-in '())))
#+END_SRC

Sometimes it is nice to send a form to the repl and evaluate it.

#+BEGIN_SRC emacs-lisp
  (defun smd/cider-send-to-repl ()
    (interactive)
    (let ((s (buffer-substring-no-properties
              (nth 0 (cider-last-sexp 'bounds))
              (nth 1 (cider-last-sexp 'bounds)))))
      (with-current-buffer (cider-current-connection)
        (insert s)
        (cider-repl-return))))
#+END_SRC

CIDER is pretty easy to setup. Cider is also pretty easy to homebrew.

#+BEGIN_SRC emacs-lisp
    (defun smd/setup-cider ()
      (interactive)
      (company-mode 1)
      (eldoc-mode 1)
      (paredit-mode 1))

    (use-package cider
      :init
      (add-hook #'cider-mode-hook #'smd/setup-cider)
      (add-hook #'cider-repl-mode-hook #'smd/setup-cider)
      :bind (("C-c C-s ." . smd/cider-send-to-repl)
             ("M-TAB"   . company-complete))
      :config (setq
               cider-clojure-cli-aliases "dev:test:debug"
               cider-hide-special-buffers t
               cider-history-file "~/.nrepl-history"
               cider-jump-to-pop-to-buffer-actions '((display-buffer-same-window))
               cider-popup-stacktraces-in-repl t
               cider-prefer-local-resources t
               cider-preferred-build-tool 'clojure-cli
               cider-repl-display-help-banner nil
               cider-repl-history-file "~/.cider-repl.log"
               cider-repl-history-size 10000
               cider-repl-pop-to-buffer-on-connect nil
               cider-repl-prompt-function 'cider-repl-prompt-abbreviated
               cider-test-show-report-on-success nil
               nrepl-log-messages nil))
#+END_SRC

=company= makes autocompletion sort of work.
=paredit= and =rainbow-delimiters= make the parentheses pretty nice.
=eldoc= shows you the docstring of a function in the echo area.

Korma functions are going to get pretty nested, so
let's not indent them too much.

#+BEGIN_SRC emacs-lisp
  (defun smd/clojure-mode-hook ()
    (cljr-add-keybindings-with-prefix "C-c C-m")
    (rainbow-delimiters-mode t)
    (projectile-mode 1)
    (display-line-numbers-mode 1)
    (company-mode 1))

  (use-package clojure-mode
    :ensure t
    :config (progn
             (use-package cider)
             (use-package clj-refactor)
             (use-package eldoc)
             (use-package company)
             (use-package yafolding)
             (use-package projectile)
             (use-package lsp-mode)
             (add-hook 'clojure-mode-hook 'smd/clojure-mode-hook))
    :bind (("C-c j" . smd/cider-jack-in-test-profile)
           ("C-c i" . imenu)
           ("C-c C-l" . cider-repl-clear-buffer)))
#+END_SRC

* Code Folding Tools

I've got files that are 15k lines long and get lost easily when faced
with a wall of text. Code folding helps by narrowing the focus in a
different way than the =narrow-to-{defun,region}= way of doing things.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yafolding
    :ensure t
    :defer t
    :config
    :bind
    (:map global-map
          ("C-x t e" . yafolding-toggle-element)
          ("C-x t a" . yafolding-toggle-all)
          ("C-x t s" . yafolding-show-element)
          ("C-x t h" . yafolding-hide-element)))
#+END_SRC

* SQL things
Sometimes you need to use a relational database for some. Since I tend to use
PostgreSQL, we need to setup sql-postgres

#+begin_src emacs-lisp :tangle yes
  (setq sql-postgres-login-params
        '((user :default "smd")
          (database :default "postgres")
          (server :default "localhost")
          (port :default 5432)))
#+end_src

"PostgreSQL databases with underscores in their names trip up the prompt
specified in sql.el. I work around this with the following. Warning, this sets
the prompt globally, which is fine by me since I only ever use Postgres."
-- [[https://www.emacswiki.org/emacs/SqlMode][EmacsWiki - SqlMode]]

#+begin_src emacs-lisp :tangle yes
(add-hook 'sql-interactive-mode-hook
            (lambda ()
              (setq sql-prompt-regexp "^[_[:alpha:]]*[=][#>] ")
              (setq sql-prompt-cont-regexp "^[_[:alpha:]]*[-][#>] ")))
#+end_src
* Treemacs
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (progn
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
            treemacs-project-follow-into-home        nil
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           35
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))

      (treemacs-hide-gitignored-files-mode nil))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-projectile
    :after (treemacs projectile)
    :ensure t)

  (use-package treemacs-icons-dired
    :hook (dired-mode . treemacs-icons-dired-enable-once)
    :ensure t)

  (use-package treemacs-magit
    :after (treemacs magit)
    :ensure t)
#+END_SRC
* Projectile
Always use Projectile because turning it on for specific things is annoying.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init (setq projectile-keymap-prefix (kbd "C-c M-p"))
    :config (projectile-global-mode))
#+END_SRC

* Snippets

Yasnippet can be setup with a pretty big collection of templates

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-=") 'yas-insert-snippet)

  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"                 ;; personal snippets
  ;;         "/path/to/some/collection/"           ;; foo-mode and bar-mode snippet collection
  ;;         "/path/to/yasnippet/yasmate/snippets" ;; the yasmate collection
  ;;         "/path/to/yasnippet/snippets"         ;; the default collection
          ))

  (yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet already.
#+END_SRC

I can make a geojson snippet with this:

#+begin_src javascript
  {
      "type": "Feature",
      "properties": {
          "name": "Janet's Cabin",
          "amenity": "Gas, electric lights, multiple rooms, ",
          "comments": "This is the first hut the Mo and I visited. It was a learning experience."
      },
      "geometry": {
          "type": "Point",
          "coordinates": [-104.99404, 39.75621]
      }
  }
#+end_src

* Javascript
Sometimes we have to write Javascript. I guess that's that, so let's try and
make it a little more _sane_, ok?

#+begin_src emacs-lisp :tangle yes
  (setq-default js-indent-indent 2)
#+end_src
* Java
[[https://github.com/emacs-lsp/lsp-java][lsp-java]] provides integration with the Eclipse JDT Language Server. This
makes doing IDE-like things with Java much nicer inside Emacs.

Here's a minimal configuration from the project's README. First, get the latest JDT.

#+BEGIN_EXAMPLE
  rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
  mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
  wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
  tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cc-mode)

    (use-package lsp-java
    :ensure t
    :requires (lsp-ui-flycheck lsp-ui-sideline)
    :init (setq
           lsp-java-organize-imports nil
           lsp-java-save-action-organize-imports nil)
    :config
    (add-hook 'java-mode-hook  'lsp-java-enable)
    (add-hook 'java-mode-hook  'dap-mode)
    (add-hook 'java-mode-hook  'flycheck-mode)
    (add-hook 'java-mode-hook  'company-mode)
    (add-hook 'java-mode-hook  'rainbow-delimiters-mode)
    (add-hook 'java-mode-hook  'display-line-numbers-mode)
    (setq lsp-java--workspace-folders
          (list "/Users/smd/src/democracyworks/colorado-rla/server/eclipse-project/")))

  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t))

  (use-package dap-java
    :after (lsp-java))
#+end_src

* Finally
Turn off debugging now that initialization is done.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC
